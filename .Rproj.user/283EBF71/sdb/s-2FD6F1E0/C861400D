{
    "contents" : "# Utilities\n# Generate color palet using number of communitie\ncommunityToColors <- function(members, num.communities) {\n  base.color <- \"#AAAAAA\"\n  num.members <- length(members)\n  colors <- array(base.color, dim=c(num.members))\n\n  # Split color space into number of communities\n  color.pallet <- rainbow(num.communities)\n\n  for(i in 1:num.members) {\n    newcolor <- color.pallet[members[i]]\n    if(length(newcolor) == 0) {\n      newcolor <- base.color\n    }\n    colors[i] <- newcolor\n  }\n  result <- array(sapply(colors,function(x){return(substring(x, 1, 7))}))\n  return(result)\n}\n\nbuildStyle <- function(style.name, g, colors, community) {\n  # Preepare Defaults\n  def.node.border.width <- list(\n    visualProperty = \"NODE_BORDER_WIDTH\",\n    value = 0\n  )\n\n  def.node.transparency <- list(\n    visualProperty=\"NODE_TRANSPARENCY\",\n    value=230\n  )\n\n  def.edge.transparency <- list(\n    visualProperty=\"EDGE_TRANSPARENCY\",\n    value=120\n  )\n\n  def.edge.width <- list(\n    visualProperty=\"EDGE_WIDTH\",\n    value=2\n  )\n\n  def.network.background <- list(\n    visualProperty = \"NETWORK_BACKGROUND_PAINT\",\n    value = \"black\"\n  )\n\n  defaults <- list(\n    def.node.border.width,\n    def.edge.width,\n    def.node.transparency,\n    def.edge.transparency,\n    def.network.background\n  )\n\n  # Mappings\n  mappings = list()\n\n  # Color mappings\n  node.fill.color = list(\n    mappingType=\"passthrough\",\n    mappingColumn=colors,\n    mappingColumnType=\"String\",\n    visualProperty=\"NODE_FILL_COLOR\"\n  )\n\n  edge.color = list(\n    mappingType=\"passthrough\",\n    mappingColumn=colors,\n    mappingColumnType=\"String\",\n    visualProperty=\"EDGE_STROKE_UNSELECTED_PAINT\"\n  )\n\n  # Node Size Mapping\n  min.betweenness = min(V(g)$betweenness)\n  max.betweenness = max(V(g)$betweenness)\n\n  point1 = list(\n    value=min.betweenness,\n    lesser= \"5.0\",\n    equal=\"5.0\",\n    greater=\"5.0\"\n  )\n\n  point2 = list(\n    value=max.betweenness,\n    lesser=\"100.0\",\n    equal=\"100.0\",\n    greater=\"100.0\"\n  )\n\n  node.size.continuous.points = list(point1, point2)\n\n  node.size = list(\n    mappingType=\"continuous\",\n    mappingColumn=\"betweenness\",\n    mappingColumnType=\"Double\",\n    visualProperty=\"NODE_SIZE\",\n    points = node.size.continuous.points\n  )\n\n  edge.trans.point = list(\n    value=1.0,\n    lesser= \"40\",\n    equal=\"200\",\n    greater=\"200\"\n  )\n\n  edge.trans.continuous.points = list(edge.trans.point)\n\n  edge.trans = list(\n    mappingType=\"continuous\",\n    mappingColumn=community,\n    mappingColumnType=\"Double\",\n    visualProperty=\"EDGE_TRANSPARENCY\",\n    points = edge.trans.continuous.points\n  )\n\n  mappings = list(node.fill.color, edge.color, node.size, edge.trans)\n\n  style <- list(title=style.name, defaults = defaults, mappings = mappings)\n  return(toJSON(style))\n}\n\n\n\n\nbuildStyleSimple <- function(style.name, g, colors) {\n  # Preepare Defaults\n  def.node.border.width <- list(\n    visualProperty = \"NODE_BORDER_WIDTH\",\n    value = 0\n  )\n\n  def.edge.width <- list(\n    visualProperty=\"EDGE_WIDTH\",\n    value=2\n  )\n\n  def.network.background <- list(\n    visualProperty = \"NETWORK_BACKGROUND_PAINT\",\n    value = \"white\"\n  )\n\n  defaults <- list(\n    def.node.border.width,\n    def.network.background\n  )\n\n  # Mappings\n  mappings = list()\n\n  # Color mappings\n  node.fill.color = list(\n    mappingType=\"passthrough\",\n    mappingColumn=colors,\n    mappingColumnType=\"String\",\n    visualProperty=\"NODE_FILL_COLOR\"\n  )\n\n  edge.color = list(\n    mappingType=\"passthrough\",\n    mappingColumn=colors,\n    mappingColumnType=\"String\",\n    visualProperty=\"EDGE_STROKE_UNSELECTED_PAINT\"\n  )\n\n#name mapping\n\tnode.label = list(\n    mappingType=\"passthrough\",\n    mappingColumn=\"name\",\n    mappingColumnType=\"String\",\n    visualProperty=\"NODE_LABEL\"\n  )\n\n  mappings = list(node.fill.color, edge.color,node.label)\n\n  style <- list(title=style.name, defaults = defaults, mappings = mappings)\n  return(toJSON(style))\n}\n\n\nprocessNodeAttributes<-function(g,g.NEL){\n  \n  g.vertexNames<-vertex_attr_names(g)\n  \n  for (index in 1:length(g.vertexNames)){\n    name<-g.vertexNames[index]\n    \n    if (class(igraph::vertex_attr(g,name = name,1))==\"character\") {\n\t  type=\"char\"\n      default=\"\"\n    }\n    else if (class(igraph::vertex_attr(g,name = name,1))==\"numeric\") {\n      type=\"numeric\"\n      default=1\n    }\n\tprint(type)\n\tprint(name)\n \tprint(default)\n    g.NEL<-initNodeAttribute(graph = g.NEL,attribute.name = name,attribute.type = type,default.value = default)\n\tif(type ==\"char\"){\n\tnodeData(self = g.NEL,n = V(g)$name,attr = name)<-vertex_attr(g,name,1:vcount(g))\n\t}\n\telse{\n\tnodeData(self = g.NEL,n = V(g)$name,attr = name)<-as.numeric(vertex_attr(g,name,1:vcount(g)))\n\t}\n    \n  }\n  nodeDataDefaults(g.NEL,\"label\")<-\"default\"\n  nodeData(self = g.NEL,V(g)$name,\"label\")<-V(g)$name\n  g.NEL<-initNodeAttribute(g.NEL,attribute.name = \"label\",attribute.type = \"char\",default.value = \"name\")\n  \n  return(g.NEL)\n}\n\nprocessEdgeAttributes<-function(g,g.NEL){\n  \n  g.edgeNames<- edge_attr_names(g)\n  \n  for (index in 1:length(g.edgeNames)){\n    name<-g.edgeNames[index]\n   \n    if (class(igraph::edge_attr(g,name = name,1))==\"character\") {\n      type=\"char\"\n      default=\"\"\n    }\n    else if (class(igraph::edge_attr(g,name = name,1))==\"numeric\") {\n      type=\"numeric\"\n      default=1\n    }\n    g.NEL<-initEdgeAttribute(g.NEL,name,type,default)\n    \n  }\n  g.NEL<-initEdgeAttribute(g.NEL,\"weight\",\"numeric\",1)\n  \n  return(g.NEL)\n}\n",
    "created" : 1447699310142.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3537612171",
    "id" : "C861400D",
    "lastKnownWriteTime" : 1447754463,
    "path" : "~/PhD/test/RGroup_Network/utils.R",
    "project_path" : "utils.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}