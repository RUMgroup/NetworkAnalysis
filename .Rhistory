else if (class(igraph::vertex_attr(g,name = name,1))=="numeric") {
type="numeric"
default=1
}
g.NEL<-initNodeAttribute(g.NEL,name,type,default)
}
return(g.NEL)
}
processNodeAttributes(g,g.NEL)
edge_attr_names()
processNodeAttributes<-function(g,g.NEL){
g.edgeNames<- edge_attr_names(g)
for (index in 1:length(g.edgeNames)){
name<-g.vertexNames[index]
igraph::vertex_attr(g,name)
if (class(igraph::edge_attr(g,name = name,1))=="character") {
type="char"
default=""
}
else if (class(igraph::edge_attr(g,name = name,1))=="numeric") {
type="numeric"
default=1
}
g.NEL<-initEdgeAttribute(g.NEL,name,type,default)
}
return(g.NEL)
}
processEdgeAttributes<-function(g,g.NEL){
g.edgeNames<- edge_attr_names(g)
for (index in 1:length(g.edgeNames)){
name<-g.vertexNames[index]
igraph::vertex_attr(g,name)
if (class(igraph::edge_attr(g,name = name,1))=="character") {
type="char"
default=""
}
else if (class(igraph::edge_attr(g,name = name,1))=="numeric") {
type="numeric"
default=1
}
g.NEL<-initEdgeAttribute(g.NEL,name,type,default)
}
return(g.NEL)
}
processEdgeAttributes(g,g.NEL)
g.Cyto<-CytoscapeWindow(title = "example",graph = g.NEL,overwriteWindow = T)
processNodeAttributes<-function(g,g.NEL){
g.vertexNames<-vertex_attr_names(g)
for (index in 1:length(g.vertexNames)){
name<-g.vertexNames[index]
igraph::vertex_attr(g,name)
if (class(igraph::vertex_attr(g,name = name,1))=="character") {
type="char"
default=""
}
else if (class(igraph::vertex_attr(g,name = name,1))=="numeric") {
type="numeric"
default=1
}
g.NEL<-initNodeAttribute(g.NEL,name,type,default)
}
return(g.NEL)
}
processEdgeAttributes<-function(g,g.NEL){
g.edgeNames<- edge_attr_names(g)
for (index in 1:length(g.edgeNames)){
name<-g.vertexNames[index]
igraph::vertex_attr(g,name)
if (class(igraph::edge_attr(g,name = name,1))=="character") {
type="char"
default=""
}
else if (class(igraph::edge_attr(g,name = name,1))=="numeric") {
type="numeric"
default=1
}
g.NEL<-initEdgeAttribute(g.NEL,name,type,default)
}
return(g.NEL)
}
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
g.Cyto<-CytoscapeWindow(title = "example",graph = g.NEL,overwriteWindow = T)
E(g)$colors.community.label.propagation
class(E(g)$colors.community.label.propagation)
processEdgeAttributes<-function(g,g.NEL){
g.edgeNames<- edge_attr_names(g)
for (index in 1:length(g.edgeNames)){
name<-g.edgeNames[index]
if (class(igraph::edge_attr(g,name = name,1))=="character") {
type="char"
default=""
}
else if (class(igraph::edge_attr(g,name = name,1))=="numeric") {
type="numeric"
default=1
}
g.NEL<-initEdgeAttribute(g.NEL,name,type,default)
}
return(g.NEL)
}
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
g.Cyto<-CytoscapeWindow(title = "example",graph = g.NEL,overwriteWindow = T)
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
g.Cyto<-CytoscapeWindow(title = "example",graph = g.NEL,overwriteWindow = T)
processNodeAttributes<-function(g,g.NEL){
g.vertexNames<-vertex_attr_names(g)
for (index in 1:length(g.vertexNames)){
name<-g.vertexNames[index]
igraph::vertex_attr(g,name)
if (class(igraph::vertex_attr(g,name = name,1))=="character") {
type="char"
default=""
}
else if (class(igraph::vertex_attr(g,name = name,1))=="numeric") {
type="numeric"
default=1
}
g.NEL<-initNodeAttribute(g.NEL,name,type,default)
}
nodeDataDefaults(g.NEL,"label")<-"default"
nodeData(self = g.NEL,V(g)$name,"label")<-V(g)$name
g.NEL<-initNodeAttribute(g.NEL,"label","char",default.value = "name")
return(g.NEL)
}
processEdgeAttributes<-function(g,g.NEL){
g.edgeNames<- edge_attr_names(g)
for (index in 1:length(g.edgeNames)){
name<-g.edgeNames[index]
if (class(igraph::edge_attr(g,name = name,1))=="character") {
type="char"
default=""
}
else if (class(igraph::edge_attr(g,name = name,1))=="numeric") {
type="numeric"
default=1
}
g.NEL<-initEdgeAttribute(g.NEL,name,type,default)
}
g.NEL<-initEdgeAttribute(g.NEL,"weight","char","black")
return(g.NEL)
}
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
g.Cyto<-CytoscapeWindow(title = "example",graph = g.NEL,overwriteWindow = T)
displayGraph(g.Cyto)
g.vertexNames
setNodeColorRule(g.Cyto,V(g)$community.greedy,V(g)$colors.community.greedy )
?setNodeColorDirect
setNodeColorDirect(g.Cyto,V(g)$community.greedy,V(g)$colors.community.greedy)
layoutNetwork(g.Cyto,"force-directed")
V(g)$colors.community.greedy
class(V(g)$colors.community.greedy)
setNodeColorDirect(g.Cyto,V(g)$name,V(g)$colors.community.greedy)
setEdgeColorDirect(g.Cyto,E(g)$name,E(g)$colors.community.greedy)
?setEdgeColorDirect
b<-edge.list(g)
igraph::get.edgelist(g)
edges<-igraph::get.edgelist(g)
edges<-paste(edges[,1],edges[,2],sep" unspecified")
edges<-paste(edges[,1],edges[,2],sep=" unspecified ")
edges
head(edges)
setEdgeColorDirect(g.Cyto,edges,E(g)$colors.community.greedy)
E(g)$colors.community.greedy
setNodeBorderWidthDirect(g.Cyto,V(g)$names,node.names = rep(0,vcount(g)))
setNodeWidthDirect()
setNodeWidthDirect
setNodeBorderWidthDirect(g.Cyto,V(g)$names,node.names = rep(230,vcount(g)))
setNodeColorDirect(g.Cyto,V(g)$name,V(g)$colors.community.greedy)
setNodeOpacityDirect(g.Cyto,V(g)$names,node.names = rep(230,vcount(g)))
setNodeBorderWidthDirect(g.Cyto,V(g)$names,V(g)$name,new.sizes = rep(0,vcount(g)))
setNodeBorderWidthDirect(g.Cyto,V(g)$name,new.sizes = rep(0,vcount(g)))
setNodeOpacityDirect(g.Cyto,V(g)$name,new.values = rep(230,vcount(g)))
?setDefaultBackgroundColor
setDefaultBackgroundColor(g.Cyto,"black")
setNodeColorDirect(g.Cyto,V(g)$name,V(g)$colors.community.greedy)
setEdgeLineWidthDirect(g.Cyto,edges,new.value = 2)
setNodeOpacityDirect(g.Cyto,V(g)$name,new.values = 230)
?setEdgeOpacityRule
setEdgeOpacityRule(g.Cyto,E(g)$community.greedy,control.points =c(40,200,200),opacities = 1,mode = "interpolate")
E(g)$community.greedy,
E(g)$community.greedy
table(E(g)$community.greedy)
?layoutNetwork
#Let's look at the yeast protein interaction network
# Load yeast network SIF file as Data Frame
yeast.table <- read.table("yeastHighQuality.sif")
# Convert it to simple edge list
yeast.table.edgelist <- yeast.table[c(1,3)]
# Convert data frame to undirected igraph object
g.original <- graph.data.frame(yeast.table.edgelist, directed=F)
# Extract componentes (individual connected subgraphs)
subgraphs <- decompose.graph(g.original)
# Pick largest subgraph
largest.subgraph <- subgraphs[[which.max(sapply(subgraphs, vcount))]]
# Remove duplicate edges
g <- simplify(largest.subgraph, remove.multiple=T, remove.loops=T)
g$name <- "Yeast network"
# Global Network Statistics
g$density <- graph.density(g) # Density
g$transitivity <- transitivity(g) # Transitivity
# Node statistics
V(g)$closeness <- closeness(g) # Closeness Centrarity
V(g)$degree <- igraph::degree(g) # Degree
V(g)$pagerank <- page.rank(g, directed = FALSE)$vector # PageRank
V(g)$betweenness <- betweenness(g) # Betweenness Centrarity
# Edge statistics
E(g)$betweenness.edge <- edge.betweenness(g) # Edge Betweenness
# Step 3: Community Detection: Try multiple algorithms
#optimise objective function - modularity
communities.greedy <- fastgreedy.community(g)
#by eginvector of the modularity matrix
communities.leading <- leading.eigenvector.community(g)
#neihgbour majority voting
communities.label.propagation <- label.propagation.community(g)
V(g)$community.greedy <- communities.greedy$membership
V(g)$community.leading <- communities.leading$membership
V(g)$community.label.propagation<- communities.label.propagation$membership
#add colour for the community labels
V(g)$colors.community.greedy <- communityToColors(
communities.greedy$membership,
length(communities.greedy))
V(g)$colors.community.leading <- communityToColors(
communities.leading$membership,
length(communities.leading))
V(g)$colors.community.label.propagation <- communityToColors(
communities.label.propagation$membership,
length(communities.label.propagation))
#work out which edges are intra community
E(g)$community.greedy <- getCommunityEdge(g, V(g)$community.greedy)
E(g)$community.leading <- getCommunityEdge(g, V(g)$community.leading)
E(g)$community.label.propagation <- getCommunityEdge(g, V(g)$community.label.propagation)
#color the edges by community
E(g)$colors.community.greedy <- communityToColors(array(E(g)$community.greedy), length(communities.greedy))
E(g)$colors.community.leading <- communityToColors(array(E(g)$community.leading), length(communities.leading))
E(g)$colors.community.label.propagation <- communityToColors(array(E(g)$community.label.propagation), length(communities.label.propagation))
#send it to cytoscape
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
E(g)$community
E(g)$community.greedy
class(E(g)$community.greedy)
source("cytoscape_util.R")
source("utils.R")
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote util functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
g.NEL
?g.NEL
g.Cyto<-CytoscapeWindow(title = "example",graph = g.NEL,overwriteWindow = T)
displayGraph(g.Cyto)
displayGraph(g.Cyto)
g.Cyto<-CytoscapeWindow(title = "example",graph = g.NEL,overwriteWindow = T)
displayGraph(g.Cyto)
initNodeAttribute(g.NEL,attribute.name = name,attribute.type = type,default.value = default)
default
name
type
source("utils.R")
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote util functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
?nodeData
vertex_attr(g,name ="name",1:10)
vertex_attr(g,name ="name",1:vcount(g))
source("utils.R")
g.NEL<-processNodeAttributes(g,g.NEL)
source("utils.R")
g.NEL<-processNodeAttributes(g,g.NEL)
#send it to cytoscape
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote util functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
#send it to cytoscape
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote util functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
Q
#send it to cytoscape
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote util functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
?nodeData
#send it to cytoscape
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote util functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
V(g)$name
nodeData(self = g.NEL,V(g)$name,"degree")<-as.numeric(vertex_attr(g,"degree",1:vcount(g)))
processNodeAttributes<-function(g,g.NEL){
g.vertexNames<-vertex_attr_names(g)
for (index in 1:length(g.vertexNames)){
name<-g.vertexNames[index]
if (class(igraph::vertex_attr(g,name = name,1))=="character") {
type="char"
default=""
}
else if (class(igraph::vertex_attr(g,name = name,1))=="numeric") {
type="numeric"
default=1
}
print(type)
print(name)
print(default)
g.NEL<-initNodeAttribute(g.NEL,name,type,default)
if(type =="char"){
nodeData(self = g.NEL,V(g)$name,name)<-vertex_attr(g,name,1:vcount(g))
}
else{
nodeData(self = g.NEL,V(g)$name,name)<-as.numeric(vertex_attr(g,name,1:vcount(g)))
}
}
nodeDataDefaults(g.NEL,"label")<-"default"
nodeData(self = g.NEL,V(g)$name,"label")<-V(g)$name
g.NEL<-initNodeAttribute(g.NEL,"label","char",default.value = "name")
return(g.NEL)
}
#send it to cytoscape
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote util functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
#send graph to cytoscape
g.Cyto<-CytoscapeWindow(title = "example",graph = g.NEL,overwriteWindow = T)
displayGraph(g.Cyto)
#send graph to cytoscape
g.Cyto<-CytoscapeWindow(title = "example",graph = g.NEL,overwriteWindow = T)
displayGraph(g.Cyto)
str(g.NEL)
summary(g)
g.NEL
str(g.NEL)
str(V(g)$name)
str(V(g)$degree)
V(g)$betweenness
source('~/PhD/test/RGroup_Network/utils.R', echo=TRUE)
g.NEL<-igraph.to.graphNEL(g)
#too many attributes to do one by one!
summary(g)
#wrote util functions to deal with it
g.NEL<-processEdgeAttributes(g,g.NEL)
g.NEL<-processNodeAttributes(g,g.NEL)
cyjs <- toCytoscape(g)
# POST it to Cytoscape
network.url = paste(base.url, "networks", sep="/")
res <- POST(url=network.url, body=cyjs, encode="json")
# Extract network SUID from the return value
network.suid = unname(fromJSON(rawToChar(res$content)))
# Step 5: Use structure information for Visual Styles
# Generate Visual Styles
style.greedy <- buildStyle("greedy", g, colors = "colors.community.greedy", community="community.greedy")
style.leading <- buildStyle("leading", g, colors = "colors.community.leading", community="community.leading")
style.label.propagation <- buildStyle("label.propagation", g,
colors = "colors.community.label.propagation", community="community.label.propagation")
style.url = paste(base.url, "styles", sep="/")
POST(url=style.url, body=style.greedy, encode = "json")
POST(url=style.url, body=style.leading, encode = "json")
POST(url=style.url, body=style.label.propagation, encode = "json")
# Apply a Style
apply.style.url = paste(base.url, "apply/styles/greedy", toString(network.suid), sep="/")
GET(apply.style.url)
# Tweak Layout parameters
layout.params = list(
name="unweighted",
value=TRUE
)
layout.params.url = paste(base.url, "apply/layouts/kamada-kawai/parameters", sep="/")
PUT(layout.params.url, body=toJSON(list(layout.params)), encode = "json")
# Apply layout
params <- paste(toString(network.suid), "?column=community.greedy", sep="")
apply.layout.url = paste(base.url, "apply/layouts/kamada-kawai", params, sep="/")
GET(apply.layout.url)
# Perform Edge Bundling
apply.bundling.url = paste(base.url, "apply/edgebundling", toString(network.suid), sep="/")
GET(apply.bundling.url)
# Toggle graphics details
lod.url = paste(base.url, "ui/lod", sep="/")
PUT(lod.url)
# Apply a Style
apply.style.url = paste(base.url, "apply/styles/label.propagation, toString(network.suid), sep="/")
GET(apply.style.url)
apply.style.url = paste(base.url, "apply/styles/label.propagation", toString(network.suid), sep="/")
GET(apply.style.url)
apply.style.url = paste(base.url, "apply/styles/label.propagation", toString(network.suid), sep="/")
GET(apply.style.url)
params <- paste(toString(network.suid), "?column=community.label", sep="")
apply.layout.url = paste(base.url, "apply/layouts/kamada-kawai", params, sep="/")
GET(apply.layout.url)
# Convert igraph object into Cytoscape.js JSON
cyjs <- toCytoscape(g)
# POST it to Cytoscape
network.url = paste(base.url, "networks", sep="/")
res <- POST(url=network.url, body=cyjs, encode="json")
# Extract network SUID from the return value
network.suid = unname(fromJSON(rawToChar(res$content)))
style.url = paste(base.url, "styles", sep="/")
POST(url=style.url, body=style.greedy, encode = "json")
POST(url=style.url, body=style.leading, encode = "json")
POST(url=style.url, body=style.label.propagation, encode = "json")
apply.style.url = paste(base.url, "apply/styles/label.propagation", toString(network.suid), sep="/")
GET(apply.style.url)
layout.params.url = paste(base.url, "apply/layouts/kamada-kawai/parameters", sep="/")
PUT(layout.params.url, body=toJSON(list(layout.params)), encode = "json")
# Apply layout
params <- paste(toString(network.suid), "?column=community.label", sep="")
apply.layout.url = paste(base.url, "apply/layouts/kamada-kawai", params, sep="/")
GET(apply.layout.url)
apply.bundling.url = paste(base.url, "apply/edgebundling", toString(network.suid), sep="/")
GET(apply.bundling.url)
# Toggle graphics details
lod.url = paste(base.url, "ui/lod", sep="/")
PUT(lod.url)
apply.style.url = paste(base.url, "apply/styles/leading", toString(network.suid), sep="/")
GET(apply.style.url)
# Tweak Layout parameters
layout.params = list(
name="unweighted",
value=TRUE
)
layout.params.url = paste(base.url, "apply/layouts/kamada-kawai/parameters", sep="/")
PUT(layout.params.url, body=toJSON(list(layout.params)), encode = "json")
params <- paste(toString(network.suid), "?column=community.leading", sep="")
apply.layout.url = paste(base.url, "apply/layouts/kamada-kawai", params, sep="/")
GET(apply.layout.url)
# Perform Edge Bundling
apply.bundling.url = paste(base.url, "apply/edgebundling", toString(network.suid), sep="/")
GET(apply.bundling.url)
# Toggle graphics details
lod.url = paste(base.url, "ui/lod", sep="/")
PUT(lod.url)
PUT(lod.url)
?POST
buildStyle()
buildStyle
g<-as.data.frame(matrix(c(1, 2, 1, 3, 1, 4, 3, 4, 2, 4),byrow = TRUE, ncol = 2)) %>%
graph.data.frame(directed = T) %>%
add.vertices(1,name=5) %>%
add.edges(c(1,5,5,1)) %>%
set_edge_attr("color", value = "red")
plot(g)
plot(g)
plot(g)
V(g)
E(g)
V(g)$size<-50
V(g)$color<-"blue"
plot(g,mark.groups = c(1,5))
V(g)$color<-c("blue","red","orange","purple","green")
plot(g)
plot(g,mark.groups = list(c(1,5),c(2,3,4)))
neighbors(g,v = 1,mode = "all")
neighbors(g,v = 5,mode = "all")
?neighbors
g<-add.vertices(graph = g,nv = 1,name="5")
neighbors(g,v = 5,mode = "all")
neighbors(g,v = "5",mode = "all")
plot(g)
plot(g)
dev.off()
plot(g)
neighbors(g,v = "5",mode = "all")
neighbors(g,v = 5,mode = "all")
neighbors(g,v = 6,mode = "all")
neighbors(g,v = "62,mode = "all")
g.NEL<-igraph.to.graphNEL(g)
g<-as.data.frame(matrix(c(1, 2, 1, 3, 1, 4, 3, 4, 2, 4),byrow = TRUE, ncol = 2)) %>%
graph.data.frame(directed = T) %>%
add.vertices(1,name=5) %>%
add.edges(c(1,5,5,1)) %>%
set_edge_attr("color", value = "red")
V(g)$name
plot(g)
neighbors(g,2)
neighbors(g,"2")
g<-as.data.frame(matrix(c(1, 2, 1, 3, 1, 4, 3, 4, 2, 4),byrow = TRUE, ncol = 2)) %>%
graph.data.frame(directed = T) %>%
add.vertices(1,name=5) %>%
add.edges(c(1,5,5,1,4,3)) %>%
set_edge_attr("color", value = "red")
plot(g)
